<!DOCTYPE html>
<html>
<head>
  <title>Team Tetris</title>
  <style>
    body {
      font-family: sans-serif;
      display: flex;
      flex-direction: column; /* Arrange title, game, controls vertically */
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      background-color: #f0f0f0;
      margin: 0;
      padding: 20px; /* Add some padding */
      box-sizing: border-box;
    }

    .container {
      text-align: center;
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 100%;
      max-width: 850px; /* Max width to keep things contained */
    }

    .game-area {
      display: flex;
      justify-content: center; /* Center items horizontally */
      align-items: flex-start; /* Align items to the top */
      gap: 30px; /* Adjust gap */
      margin-top: 20px;
      width: 100%; /* Take full width of container */
    }

    #player1-area, #player2-area, #next-piece-area {
      border: 1px solid #ccc;
      padding: 15px; /* Adjust padding */
      background-color: #fff;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    #next-piece-area {
      width: 140px; /* Width for next piece display */
      min-height: 140px; /* Ensure some height */
      justify-content: center; /* Center canvas vertically */
      padding-top: 40px; /* Add padding above canvas for title */
      position: relative; /* For positioning title */
    }

     #player1-area h2, #player2-area h2, #next-piece-area h2 {
         margin-top: 0;
         margin-bottom: 10px; /* Space below title */
         font-size: 1.1em;
     }

     #next-piece-area h2 {
         position: absolute; /* Position title within the area */
         top: 15px;
         left: 15px;
         right: 15px; /* Center text */
         margin: 0;
     }

    canvas {
      border: 1px solid black;
      display: block;
      margin: 5px auto;
    }

    #tetris-canvas, #blaster-canvas {
        width: 240px;
        height: 480px;
        background-color: #e0e0e0;
    }

    #next-piece-canvas {
        width: 96px; /* 4 * BLOCK_SIZE (24) */
        height: 96px;
        background-color: #e0e0e0;
        border: 1px solid #aaa;
    }

    #blaster-canvas-container {
        position: relative;
        width: 240px;
        height: 480px;
        margin: 5px auto;
        cursor: none;
        background-color: #e0e0e0; /* Match canvas background */
        overflow: hidden;
    }

    #laser-dot {
        position: absolute;
        width: 10px;
        height: 10px;
        background-color: red;
        border-radius: 50%;
        pointer-events: none;
        transform: translate(-50%, -50%);
        z-index: 10;
        display: none;
        border: 1px solid darkred;
        box-shadow: 0 0 5px red;
    }

    .marked-dot {
        position: absolute;
        width: 8px;
        height: 8px;
        background-color: rgba(0, 255, 0, 0.7);
        border-radius: 50%;
        pointer-events: none;
        z-index: 15;
        border: 1px solid darkgreen;
        box-shadow: 0 0 3px green;
        transform: translate(-50%, -50%);
    }

    #p1-score, #p2-score {
        margin-top: 15px;
        font-weight: bold;
        height: 20px; /* Ensure consistent height */
        font-size: 0.9em;
    }

    .hidden {
        display: none;
    }

    #game-over {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: rgba(0, 0, 0, 0.85);
        color: white;
        padding: 30px 40px;
        border-radius: 10px;
        text-align: center;
        z-index: 100;
        border: 2px solid #eee;
    }

    #game-over h2 {
        margin-bottom: 15px;
        margin-top: 0;
    }

    #restart-button-gameover {
        padding: 12px 25px;
        font-size: 1.1em;
        cursor: pointer;
        margin-top: 20px;
        background-color: #4CAF50;
        color: white;
        border: none;
        border-radius: 5px;
    }
     #restart-button-gameover:hover {
         background-color: #3e8e41;
     }

    .controls-overlay {
        margin-top: 25px;
        display: flex;
        gap: 15px;
        align-items: center; /* Align items vertically */
    }

    .controls-overlay button {
        padding: 10px 20px;
        font-size: 1em;
        cursor: pointer;
        background-color: #007bff;
        color: white;
        border: none;
        border-radius: 5px;
        min-width: 100px;
    }

    .controls-overlay button:hover {
        background-color: #0056b3;
    }
     .controls-overlay button:disabled {
         background-color: #cccccc;
         cursor: not-allowed;
     }


     .controls-overlay button#restart-button {
         background-color: #dc3545;
     }
     .controls-overlay button#restart-button:hover {
          background-color: #c82333;
     }

     /* Speed Control Styles */
    #speed-control-area {
        margin-top: 20px;
        display: flex;
        align-items: center;
        gap: 10px;
        background-color: #eee;
        padding: 10px 15px;
        border-radius: 5px;
        border: 1px solid #ccc;
    }
    #speed-control-area label {
        font-weight: bold;
        font-size: 0.9em;
    }
    #speed-slider {
        width: 150px;
        cursor: pointer;
    }
    #speed-value {
        font-size: 0.9em;
        min-width: 50px; /* Prevent layout shift */
        text-align: right;
        font-family: monospace;
    }

  </style>
</head>
<body>
  <div class="container">
    <h1>Team Tetris</h1>
    <div class="game-area">
      <div id="player1-area">
        <h2>Player 1 (Tetris)</h2>
        <canvas id="tetris-canvas"></canvas> <!-- Dimensions set by CSS/JS -->
        <div id="p1-score">Score: 0</div>
      </div>
      <div id="player2-area">
        <h2>Player 2 (Blaster)</h2>
        <div id="blaster-canvas-container">
           <canvas id="blaster-canvas"></canvas>
           <div id="laser-dot"></div>
           <!-- Marked dots added here -->
        </div>
         <div id="p2-score">Score: 0 Shots: 0</div>
      </div>
      <!-- Next Piece Display Area -->
      <div id="next-piece-area">
        <h2>Next Piece</h2>
        <canvas id="next-piece-canvas"></canvas>
      </div>
    </div>
     <div id="game-over" class="hidden">
        <h2>Game Over!</h2>
        <p id="winner-message"></p>
        <button id="restart-button-gameover">Restart Game</button>
    </div>
    <!-- Control Buttons Overlay -->
    <div class="controls-overlay">
        <button id="start-pause-button">Start</button>
        <button id="restart-button">Restart</button>
    </div>
     <!-- Speed Control Area -->
     <div id="speed-control-area">
         <label for="speed-slider">Speed (ms/drop):</label>
         <input type="range" id="speed-slider" min="100" max="1000" step="50" value="1000">
         <span id="speed-value">1000ms</span>
     </div>
  </div>

  <script type="module">
    // --- Get DOM Elements ---
    const tetrisCanvas = document.getElementById('tetris-canvas');
    const tetrisCtx = tetrisCanvas.getContext('2d');
    const blasterCanvas = document.getElementById('blaster-canvas');
    const blasterCtx = blasterCanvas.getContext('2d');
    const nextPieceCanvas = document.getElementById('next-piece-canvas');
    const nextPieceCtx = nextPieceCanvas.getContext('2d');
    const p1ScoreEl = document.getElementById('p1-score');
    const p2ScoreEl = document.getElementById('p2-score');
    const blasterContainer = document.getElementById('blaster-canvas-container');
    const laserDot = document.getElementById('laser-dot');
    const gameOverScreen = document.getElementById('game-over');
    const winnerMessage = document.getElementById('winner-message');
    const restartButtonGameOver = document.getElementById('restart-button-gameover');
    const startPauseButton = document.getElementById('start-pause-button');
    const restartButton = document.getElementById('restart-button');
    const speedSlider = document.getElementById('speed-slider');
    const speedValueDisplay = document.getElementById('speed-value');


    // --- Game Constants ---
    const COLS = 10;
    const ROWS = 20;
    const BLOCK_SIZE = 24; // Fixed block size
    const POINTS_PER_LINE = 100;
    const POINTS_PER_BLAST = 25;
    const SHOTS_PER_LINE_CLEAR = 5;
    const INITIAL_SHOTS = 10;
    const BASE_DROP_INTERVAL = 1000; // Default starting speed
    // const MIN_DROP_INTERVAL = 100; // Slider min sets this now
    // const SPEED_INCREASE_FACTOR = 0.88; // Removed auto-speed increase
    // const LINES_PER_LEVEL = 10; // Removed auto-speed increase

    // Set canvas dimensions based on constants
    tetrisCanvas.width = COLS * BLOCK_SIZE;
    tetrisCanvas.height = ROWS * BLOCK_SIZE;
    blasterCanvas.width = COLS * BLOCK_SIZE;
    blasterCanvas.height = ROWS * BLOCK_SIZE;
    nextPieceCanvas.width = 4 * BLOCK_SIZE; // Accommodate 4x4 grid
    nextPieceCanvas.height = 4 * BLOCK_SIZE;


    // --- Tetromino Shapes and Colors ---
    const SHAPES = [
        [[1, 1, 1, 1]], // I
        [[1, 1], [1, 1]], // O
        [[0, 1, 0], [1, 1, 1]], // T
        [[1, 0, 0], [1, 1, 1]], // L
        [[0, 0, 1], [1, 1, 1]], // J
        [[0, 1, 1], [1, 1, 0]], // S
        [[1, 1, 0], [0, 1, 1]]  // Z
    ];
    const COLORS = [
        null, 'cyan', 'yellow', 'purple', 'orange', 'blue', 'lime', 'red'
    ];

    // --- Game State Variables ---
    let p1Board;
    let p2BoardRepresentation;
    let currentPiece;
    let nextPiece;
    let p1Score;
    let p2Score;
    let availableShots;
    let totalLinesCleared; // Still useful for score or other mechanics
    let dropCounter;
    let dropInterval; // Now controlled by slider
    let gameOver;
    let gamePaused;
    let animationFrameId;
    let lastTime = 0;

    // --- Blaster State Variables ---
    let mouseX = 0;
    let mouseY = 0;
    let markedDots = [];
    let isMarking = false;

    // --- Player 1: Tetris Logic ---

    function createEmptyBoard() {
        return Array.from({ length: ROWS }, () => Array(COLS).fill(0));
    }

    function getRandomPiece() {
        const typeId = Math.floor(Math.random() * SHAPES.length) + 1;
        const shape = SHAPES[typeId - 1];
        return {
            x: Math.floor(COLS / 2) - Math.floor(shape[0].length / 2),
            y: 0,
            shape: shape,
            colorIndex: typeId
        };
    }

    function isValidMove(piece, board) {
        for (let y = 0; y < piece.shape.length; y++) {
            for (let x = 0; x < piece.shape[y].length; x++) {
                if (piece.shape[y][x]) {
                    const boardX = piece.x + x;
                    const boardY = piece.y + y;
                    if (
                        boardX < 0 || boardX >= COLS ||
                        boardY >= ROWS ||
                        (boardY >= 0 && board[boardY]?.[boardX] > 0)
                    ) {
                        return false;
                    }
                }
            }
        }
        return true;
    }

    function rotatePiece(piece) {
        const rows = piece.shape.length;
        const cols = piece.shape[0].length;
        const newShape = Array.from({ length: cols }, () => Array(rows).fill(0));
        for (let y = 0; y < rows; y++) {
            for (let x = 0; x < cols; x++) {
                newShape[x][rows - 1 - y] = piece.shape[y][x];
            }
        }
        return newShape;
    }

    function handlePlayer1Input(event) {
        if (gameOver || gamePaused || !currentPiece) return;

        const key = event.key.toUpperCase();
        let moved = false;
        let testPiece = JSON.parse(JSON.stringify(currentPiece));

        switch (key) {
            case 'ARROWLEFT': case 'L':
                testPiece.x--;
                if (isValidMove(testPiece, p1Board)) { currentPiece.x--; moved = true; }
                break;
            case 'ARROWRIGHT': case 'R':
                testPiece.x++;
                if (isValidMove(testPiece, p1Board)) { currentPiece.x++; moved = true; }
                break;
            case 'ARROWDOWN': case 'D':
                testPiece.y++;
                if (isValidMove(testPiece, p1Board)) { currentPiece.y++; dropCounter = 0; moved = true; }
                else { lockPiece(); moved = false; }
                break;
            case 'ARROWUP': case 'U':
                testPiece.shape = rotatePiece(currentPiece);
                let kickX = 0;
                 if (!isValidMove(testPiece, p1Board)) {
                    testPiece.x--; if (isValidMove(testPiece, p1Board)) kickX = -1;
                    else { testPiece.x += 2; if (isValidMove(testPiece, p1Board)) kickX = 1; else testPiece.x--; }
                 }
                 if (!isValidMove(testPiece, p1Board)) { testPiece.shape = currentPiece.shape; }
                 else { currentPiece.shape = testPiece.shape; currentPiece.x += kickX; moved = true; }
                break;
        }

        if (moved) { drawTetris(); drawBlasterView(); }
    }

    function lockPiece() {
        if (!currentPiece) return;
        let toppedOut = false;
        currentPiece.shape.forEach((row, y) => {
            row.forEach((value, x) => {
                if (value) {
                     const boardY = currentPiece.y + y; const boardX = currentPiece.x + x;
                     if (boardY < 0) toppedOut = true;
                     else if (boardY < ROWS && boardX >= 0 && boardX < COLS) {
                        p1Board[boardY][boardX] = currentPiece.colorIndex;
                        if (p2BoardRepresentation[boardY]) p2BoardRepresentation[boardY][boardX] = currentPiece.colorIndex;
                     }
                }
            });
        });
        currentPiece = null;
        if (toppedOut) { endGame("Player 2"); drawTetris(); drawBlasterView(); return; }
        const linesWereCleared = checkLineClears();
        if (!gameOver) {
             spawnNewPiece();
             if(!linesWereCleared) { drawTetris(); drawBlasterView(); }
        }
    }

    function spawnNewPiece() {
         if (gameOver) return;
         currentPiece = nextPiece || getRandomPiece();
         nextPiece = getRandomPiece();
         if (!isValidMove(currentPiece, p1Board)) {
             currentPiece = null; endGame("Player 2"); drawTetris(); drawBlasterView(); return;
         }
         drawNextPiece(); // Update the preview
    }

    function checkLineClears() {
        if (gameOver) return false;
        let linesClearedThisCheck = 0;
        for (let y = ROWS - 1; y >= 0; y--) {
            if (p1Board[y] && p1Board[y].every(cell => cell > 0)) {
                linesClearedThisCheck++;
                p1Board.splice(y, 1); p2BoardRepresentation.splice(y, 1);
                p1Board.unshift(Array(COLS).fill(0)); p2BoardRepresentation.unshift(Array(COLS).fill(0));
                y++;
            }
        }
        if (linesClearedThisCheck > 0) {
            p1Score += linesClearedThisCheck * POINTS_PER_LINE * Math.pow(linesClearedThisCheck, 2);
            availableShots += linesClearedThisCheck * SHOTS_PER_LINE_CLEAR;
            totalLinesCleared += linesClearedThisCheck;
            // Speed handled manually now
            updateScores(); drawTetris(); drawBlasterView();
            return true;
        }
        return false;
    }

    function player1Drop() {
        if (gameOver || gamePaused || !currentPiece) return;
        let testPiece = { ...currentPiece, y: currentPiece.y + 1 };
        if (isValidMove(testPiece, p1Board)) {
            currentPiece.y++; dropCounter = 0; drawTetris(); drawBlasterView();
        } else { lockPiece(); }
    }

    // --- Player 2: Blaster Logic ---

    function handleBlasterMouseMove(event) {
        if (gameOver || gamePaused) return;
        const rect = blasterContainer.getBoundingClientRect();
        mouseX = event.clientX - rect.left; mouseY = event.clientY - rect.top;
        mouseX = Math.max(0, Math.min(blasterCanvas.width -1, mouseX));
        mouseY = Math.max(0, Math.min(blasterCanvas.height -1, mouseY));
        laserDot.style.left = `${mouseX}px`; laserDot.style.top = `${mouseY}px`;
        laserDot.style.display = 'block';
        if (isMarking) tryMarkBlock(mouseX, mouseY);
    }

    function handleMouseLeaveBlaster() { if (!isMarking) laserDot.style.display = 'none'; }

    function handleBlasterMouseDown(event) {
        if (gameOver || gamePaused || event.button !== 0) return;
        isMarking = true;
        tryMarkBlock(mouseX, mouseY);
        event.preventDefault();
    }

    function handleWindowMouseUp(event) { if (event.button === 0) isMarking = false; }

    function tryMarkBlock(canvasX, canvasY) {
         if (availableShots <= 0) return; // Strict check
        const targetCol = Math.floor(canvasX / BLOCK_SIZE); const targetRow = Math.floor(canvasY / BLOCK_SIZE);
        if (targetRow >= 0 && targetRow < ROWS && targetCol >= 0 && targetCol < COLS && p1Board[targetRow]?.[targetCol] > 0) {
            const isAlreadyMarked = markedDots.some(dot => dot.row === targetRow && dot.col === targetCol);
            if (!isAlreadyMarked) {
                // Only add mark and decrement shots if not already marked AND shots > 0
                 addMarkedDotVisual(targetRow, targetCol);
                 availableShots--; // Decrement only when adding a new mark
                 updateScores();
            }
        }
    }

    function handleBlasterRightClick(event) {
        if (gameOver || gamePaused) return; event.preventDefault();
        fireBlasts(); clearMarkedDotVisuals();
    }

    function addMarkedDotVisual(row, col) {
        const dot = document.createElement('div'); dot.classList.add('marked-dot');
        dot.style.left = `${col * BLOCK_SIZE + BLOCK_SIZE / 2}px`; dot.style.top = `${row * BLOCK_SIZE + BLOCK_SIZE / 2}px`;
        dot.dataset.row = row; dot.dataset.col = col;
        blasterContainer.appendChild(dot);
        markedDots.push({ row: row, col: col, element: dot });
    }

    function clearMarkedDotVisuals() {
        markedDots.forEach(dot => dot.element?.remove()); markedDots = [];
    }

    function applyGravity(col, startRow) {
        for (let r = startRow; r >= 0; r--) {
             if (p1Board[r]?.[col] > 0) {
                let fallToRow = r;
                while (fallToRow + 1 < ROWS && p1Board[fallToRow + 1]?.[col] === 0) fallToRow++;
                if (fallToRow > r) {
                    p1Board[fallToRow][col] = p1Board[r][col]; p1Board[r][col] = 0;
                    if (p2BoardRepresentation[fallToRow] && p2BoardRepresentation[r]) {
                         p2BoardRepresentation[fallToRow][col] = p2BoardRepresentation[r][col];
                         p2BoardRepresentation[r][col] = 0;
                    }
                }
            }
        }
    }

    function fireBlasts() {
        if (markedDots.length === 0) return;
        let blastHit = false;
        markedDots.forEach(dot => {
            const targetRow = dot.row; const targetCol = dot.col;
            if (targetRow >= 0 && targetRow < ROWS && targetCol >= 0 && targetCol < COLS && p1Board[targetRow]?.[targetCol] > 0) {
                p1Board[targetRow][targetCol] = 0;
                if (p2BoardRepresentation[targetRow]) p2BoardRepresentation[targetRow][targetCol] = 0;
                p2Score += POINTS_PER_BLAST; blastHit = true;
                applyGravity(targetCol, targetRow);
            }
        });
        if (blastHit) { updateScores(); drawTetris(); drawBlasterView(); }
    }


    // --- Drawing Functions ---

    // drawBlock adjusted slightly for potentially different contexts
    function drawBlockOnCanvas(ctx, x, y, colorIndex, blockSize) {
         if (colorIndex > 0) {
            ctx.fillStyle = COLORS[colorIndex];
            ctx.fillRect(x * blockSize, y * blockSize, blockSize, blockSize);
            ctx.strokeStyle = 'rgba(0,0,0,0.5)';
            ctx.lineWidth = 1;
            ctx.strokeRect(x * blockSize + 0.5, y * blockSize + 0.5, blockSize -1, blockSize -1);
         }
    }

    function drawBoard(ctx, board) {
        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
        board.forEach((row, y) => {
            row.forEach((value, x) => {
                if (y >= 0) drawBlockOnCanvas(ctx, x, y, value, BLOCK_SIZE);
            });
        });
    }

    function drawPiece(ctx, piece) {
        if (!piece) return;
        piece.shape.forEach((row, y) => {
            row.forEach((value, x) => {
                if (value && piece.y + y >= 0) {
                    drawBlockOnCanvas(ctx, piece.x + x, piece.y + y, piece.colorIndex, BLOCK_SIZE);
                }
            });
        });
    }

    function drawTetris() { if (!tetrisCtx) return; drawBoard(tetrisCtx, p1Board); drawPiece(tetrisCtx, currentPiece); }
    function drawBlasterView() { if (!blasterCtx) return; drawBoard(blasterCtx, p2BoardRepresentation); }

    // --- Draw Next Piece ---
    function drawNextPiece() {
        if (!nextPieceCtx || !nextPiece) return;

        // Clear the small canvas
        nextPieceCtx.clearRect(0, 0, nextPieceCanvas.width, nextPieceCanvas.height);
        // Optional: Fill background if needed
        // nextPieceCtx.fillStyle = '#e0e0e0';
        // nextPieceCtx.fillRect(0, 0, nextPieceCanvas.width, nextPieceCanvas.height);


        const shape = nextPiece.shape;
        const colorIndex = nextPiece.colorIndex;
        const shapeWidth = shape[0].length;
        const shapeHeight = shape.length;

        // Calculate offsets to center the piece in the 4x4 grid area
        const offsetX = Math.floor((4 - shapeWidth) / 2);
        const offsetY = Math.floor((4 - shapeHeight) / 2);

        // Draw the piece centered
        shape.forEach((row, y) => {
            row.forEach((value, x) => {
                if (value) {
                    drawBlockOnCanvas(nextPieceCtx, offsetX + x, offsetY + y, colorIndex, BLOCK_SIZE);
                }
            });
        });
    }

    // --- Game Loop ---

    function gameLoop(timestamp) {
        if (gameOver || gamePaused) { animationFrameId = null; return; }
        const deltaTime = timestamp - lastTime; lastTime = timestamp;
        dropCounter += deltaTime;
        if (dropCounter > dropInterval) player1Drop();
        animationFrameId = requestAnimationFrame(gameLoop);
    }

    // --- Score and Game State Updates ---

    function updateScores() {
        p1ScoreEl.textContent = `Score: ${p1Score}`;
        p2ScoreEl.textContent = `Score: ${p2Score} Shots: ${availableShots}`;
    }

    function endGame(winner) {
         if (gameOver) return; gameOver = true; gamePaused = true; isMarking = false;
         if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; }
         let winnerText = winner ? `${winner} Wins!` : (p1Score > p2Score ? "Player 1 Wins!" : (p2Score > p1Score ? "Player 2 Wins!" : "It's a Tie!"));
         winnerMessage.textContent = winnerText;
         gameOverScreen.classList.remove('hidden');
         startPauseButton.textContent = "Start"; startPauseButton.disabled = true;
         removeEventListeners();
    }

    // --- Controls: Pause / Resume / Restart / Speed ---
    function togglePauseResume() {
        if (gameOver) return; gamePaused = !gamePaused;
        if (gamePaused) {
            isMarking = false; if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; }
            startPauseButton.textContent = "Resume"; console.log("Game Paused");
        } else {
            startPauseButton.textContent = "Pause"; lastTime = performance.now();
            if (!animationFrameId) animationFrameId = requestAnimationFrame(gameLoop);
             console.log("Game Resumed");
        }
    }

    function restartGame() {
         console.log("Restarting game...");
         if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; }
         isMarking = false; removeEventListeners(); initializeGame(); gamePaused = true; gameOver = false;
         startPauseButton.textContent = "Start"; startPauseButton.disabled = false;
         gameOverScreen.classList.add('hidden');
    }

    function handleSpeedChange(event) {
         const newInterval = parseInt(event.target.value, 10);
         dropInterval = newInterval; // Update the game's interval
         speedValueDisplay.textContent = `${newInterval}ms`; // Update the display
         // console.log(`Speed set to: ${dropInterval}ms`);
    }


    // --- Event Listener Management ---
    function addEventListeners() {
         document.addEventListener('keydown', handlePlayer1Input);
         blasterContainer.addEventListener('mousemove', handleBlasterMouseMove);
         blasterContainer.addEventListener('mouseleave', handleMouseLeaveBlaster);
         blasterContainer.addEventListener('mousedown', handleBlasterMouseDown);
         blasterContainer.addEventListener('contextmenu', handleBlasterRightClick);
         window.addEventListener('mouseup', handleWindowMouseUp);
         speedSlider.addEventListener('input', handleSpeedChange); // Listener for speed slider
    }

    function removeEventListeners() {
         document.removeEventListener('keydown', handlePlayer1Input);
         blasterContainer.removeEventListener('mousemove', handleBlasterMouseMove);
         blasterContainer.removeEventListener('mouseleave', handleMouseLeaveBlaster);
         blasterContainer.removeEventListener('mousedown', handleBlasterMouseDown);
         blasterContainer.removeEventListener('contextmenu', handleBlasterRightClick);
         window.removeEventListener('mouseup', handleWindowMouseUp);
         speedSlider.removeEventListener('input', handleSpeedChange);
    }


    // --- Game Initialization ---
    function initializeGame() {
        p1Board = createEmptyBoard(); p2BoardRepresentation = createEmptyBoard();
        p1Score = 0; p2Score = 0; availableShots = INITIAL_SHOTS; totalLinesCleared = 0;
        dropCounter = 0; dropInterval = parseInt(speedSlider.value, 10); // Init speed from slider
        gameOver = false; gamePaused = true; currentPiece = null;
        nextPiece = getRandomPiece(); lastTime = 0; isMarking = false;

        clearMarkedDotVisuals(); updateScores();

        // Update speed slider display initially
        speedValueDisplay.textContent = `${dropInterval}ms`;

        drawTetris(); drawBlasterView(); spawnNewPiece(); // Includes drawNextPiece()
        addEventListeners();
        console.log("Game Initialized. Press Start.");
    }

    // --- Attach Control Button Listeners ---
    startPauseButton.addEventListener('click', togglePauseResume);
    restartButton.addEventListener('click', restartGame);
    restartButtonGameOver.addEventListener('click', restartGame);

    // --- Initial Game Setup ---
    initializeGame(); // Setup the game state, initially paused

  </script>
</body>
</html>